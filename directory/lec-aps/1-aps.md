# APS : Algorithm Problem Solving

<div style="text-align: right"> 24. 02. 22. ~ 24. 02. 23. </div>

## 1. Start

### 1. SW 문제 해결

* SW 문제 해결 역량

    * 무엇인가를 이해하고 역량을 강화하는 방법

    * 문제 해결 과정

        1. 문제를 읽고 이해

        2. 문제를 익숙한 용어로 재정의

        3. 어떻게 해결할지 계획을 세운다

        4. 계획을 검증

        5. 프로그램으로 구현

        6. 어떻게 풀었는지 복기 / 디버깅, 개선 여지 확인

### 2. 복잡도 분석 - 시간 복잡도

* 알고리즘

    * 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

* 알고리즘의 효율

    * 공간적 효율성

        * 연산량 대비 얼마나 적은 메모리 공간을 요하는가
    
    * 시간적 효율성

        * 연산량 대비 얼마나 적은 시간을 요하는가

    * 복잡도 (Complexity)

        * 효율성을 뒤집어 표현

        * 복잡도가 높을수록 효율성이 저하

        * 시간 복잡도 → 반복문을 얼마나 많이 사용했나??

* 시간적 복잡도 분석

    * 하드웨어 환경, 소프트웨어 환경에 영향

    * 복잡도의 점근적 표기

        * 시간 / 공간 복잡도는 입력 크기에 대한 함수로 표기 - 여러 개의 항을 가지는 다항식

        * 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용

        * 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용

            * $O$-표기

            * $\Omega$-표기

            * $\Theta$-표기

    * $O$-표기

        * 복잡도의 *점근적 상한*을 나타냄

        * 복잡도가 $f(n) = 2n^2 - 7n + 4$이라면, $f(n)$의 $O$-표기는 $O(n^2)$이다.

        * $f(n)$의 단순화된 표현은 $n^2$이다.

            * 단순화된 함수 $n^2$에 임의의 상수 $c$를 곱한 $cn^2$이 $n$이 증가함에 따라 $f(n)$의 상한이 된다. (단, $c > 0$)

        * 단순히 *실행시간이 $n^2$에 비례*하는 알고리즘이라고 말함

        ![Complexity Analysis](image/1.PNG)

        * 자주 사용하는 $O$-표기

            | $O$-Notation | Explanation | Example |
            | :---: | :---: | :---: |
            | $O(1)$ | 상수 시간 (Constant Time) | deque - popleft() |
            | $O(log n)$ | 로그(대수) 시간 (Logarithmic Time) | BinarySearch |
            | $O(n)$ | 선형 시간 (Linear Time) | CountingSort, pop(0) |
            | $O(n log n)$ | 로그 선형 시간 (Log-linear Time) | sort() |
            | $O(n^2)$ | 제곱 시간 (Quadratic Time) | BubbleSort |
            | $O(n^3)$ | 세제곱 시간 (Cubic Time) | |
            | $O(2^n)$ | 지수 시간 (Exponential Time) | |
            | |

            ![Comparing Big-O Functions](image/2.jpg)

    * $\Omega$-표기

        * 복잡도의 *점근적 하한*을 나타냄

        * $f(n) = 2n^2 - 7n + 4$이라면, $f(n)$의 $\Omega$-표기는 $O(n^2)$이다.

        * $f(n) = \Omega(n^2)$은 $n$이 증가함에 따라 $2n^2 - 7n + 4$가 $cn^2$보다 작을 수 없다라는 의미
        
            * 이때, $c = 1$

        * $O$-표기 때와 마찬가지로 $\Omega$-표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 됨

        * **최소한 이만한 시간은 걸린다**

    * $\Theta$-표기

        * $O$-표기와 $\Omega$-표기가 같은 경우 사용

        * $f(n) = 2n^2 - 7n + 4$의 경우 $O(n^2) = \Omega(n^2)$이므로, $f(n) = \Theta(n^2)$이다.

        * $f(n)$은 *$n$이 증가함에 따라 $n^2$와 동일한 증가율을 가진다*라는 의미

### 3. 표준 입출력 방법 - sys module (파일 입출력)
### 4. 진수

* 2진수, 8진수, 10진수, 16진수

    * 10진수(DEC) : 사람이 사용하는 진수,  수 하나를 0 ~ 9로 표현

    * 2진수(BIN) : 컴퓨터가 상요하는 진수, 수 하나를 0, 1로 표현

    * 8진수(OCT) : 2진수를 더 가독성 있게 사용

    * 16진수(HEX) : 2진수를 더 가독성 있게 사용, 수 하나를 0, 1, ..., 8, 9, A, B, C, D, E, F로 표현

        * 2진수를 사람이 이해하기 편하도록 10진수로 변환 시 → 인간이 이해하기 편하지만, 연산이 오래 걸림

        * 2진수를 사람이 이해하기 편하도록 16진수로 변환 시 → 인간이 이해하기 어렵지만, 연산이 매우 빠름

    | 2진수 | 10진수 | 16진수 |
    | :---: | :---: | :---: |
    | 0000 | 0 | 0 |
    | 0001 | 1 | 1 |
    | 0010 | 2 | 2 |
    | 0011 | 3 | 3 |
    | 0100 | 4 | 4 |
    | 0101 | 5 | 5 |
    | 0110 | 6 | 6 |
    | 0111 | 7 | 7 |
    | 1000 | 8 | 8 |
    | 1001 | 9 | 9 |
    | 1010 | 10 | A |
    | 1011 | 11 | B |
    | 1100 | 12 | C |
    | 1101 | 13 | D |
    | 1110 | 14 | E |
    | 1111 | 15 | F |
    | |

        * 예시

            * 0xF9 = 15 + 9 = 1111 0101(2)

            * 0xBB3 = 1011 1011 0011(2)

            * 1100101111(2) = 0011 0010 1111(2) = 0x32F

### 5. 비트 연산

* 비트와 바이트

    * 1 bit : 0과 1로 표현하는 정보의 단위

    * 1 Byte : 8 bit를 묶어 1 Byte

        * 1001 0110 1101 1100 : 16 bit / 2 Byte

* 비트 연산

    * AND / OR 연산자

        | 연산자 | 연산자의 기능 |
        | :---: | :---: |
        | & | bit 단위로 AND 연산<br>num1 & num2 |
        | \| | bit 단위로 OR 연산<br>num1 \| num2 |
        | ^ | bit 단위로 XOR 연산<br>같으면 0, 다르면 1<br>어떤 값이던 임의의 수로 2회 XOR를 하면 원래 수로 돌아온다 - 암호화에 응용 가능<br>num1 ^ num2 |
        | ~ | 피연산자의 모든 비트를 반전<br>단항 연산자<br>~num |
        | |

    * Python 에서 2진수 / 16진수 / 10진수 변환해 출력하기

        * 10진수를 2, 16진수로 변환

            ```python
            print(bin(10))  # 0b1010
            print(hex(10))  # 0xa
            ```

        * 2, 16진수 문자열(str)을 10진수로 변환

            ```python
            print(int('1011', 2))   # 2진수
            print(int('b', 16))     # 16진수
        ```

    * Left / Right Shift 연산자

        | 연산자 | 연산자의 기능 |
        | :---: | :---: |
        | << | 피연산자의 비트 열을 왼쪽으로 이동시킨다<br>num << 2 # 2회 이동<br>print(bin(0b1101 << 2)) |
        | >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다<br>오른쪽 마지막에 1이 있었다면 그 1은 제거됨<br>num >> 2 # 2회 이동<br>print(bin(0b1101 >> 2)) |
        | |

        * 1 << n

            * $2^n$개의 값을 갖는다.

            * 원소가 n개일 경우의 모든 부분집합 수를 의미

            * Powerset (모든 부분 집합)

                * 공집합과 자기 자신을 포함한 모든 부분집합

                * 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨

        * i & (1 << j)

            * 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미함

    * NOT 연산자 (~)

        * 모든 비트를 반전시킨다

        * Python 이 ~4를 5로 출력하는 과정

            * 4는 0b0100 (MSB : 양수이므로 0)

            * NOT 연산자로 인해 뒤집으면 1011

            * MSB는 1이 되었고 (음수), 나머지 bit는 011

            * 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101 = 5

            * 따라서 -5가 된다.

* 음수 표현 방법

    * 컴퓨터는 음수를 *2의 보수*로 관리한다.

        * 맨 앞자리 bit (MSB)는 음수 / 양수를 구분하는 비트이다.

            * MSB : 1 → 음수, 0 → 양수

        * 컴퓨터가 2의 보수를 사용해 음수를 간리하는 이유

            * 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용

    | 정수 | 표현 |
    | :---: | :---: |
    | -5 | 11111011 |
    | -4 | 11111100 |
    | -3 | 11111101 |
    | -2 | 11111110 |
    | -1 | 11111111 |
    | 0 | 00000000 |

    * -5를 2의 보수로 표현하는 방법 (가정 : 수를 8 bit로 저장하는 경우)

        * 수 5를 2진수로 나타내면 000 0101 (7 bit)
        
        * -5는 음수이기에 MSB는 1

        * 나머지 7 bit에 대해, 수를 뒤집고 1을 더하면 된다. (2의 보수)

        * 수 5를 뒤집고 1을 더하면 111 1011

        * -5 = 1111 1011


    * 2의 보수 예시

        * 10001의 2의 보수

            * 수를 모두 뒤집고 +1을 한다. → 01110 + 1 = 01111

        * 1111000의 2의 보수

            * 수를 뒤집으면 0000111이고, + 1을 한다

            * 0000111 + 1 = 0001000


### 6. 실수

* Python 에서 실수 출력 방법

    * Python 은 f-string 문법을 지향한다.

        ```python
        t1 = 10
        t2 = 3.141592

        print(f'변수 값은 {t1} 입니다.')        # 변수 값은 10 입니다.
        print(f'변수 값은 {t2:.2f} 입니다.')    # 변수 값은 3.14 입니다.
        ```

* Python 에서의 실수 표현 범위

    * Python 에서는 다른 언어와 달리 내부적으로 더 많은 bit를 사용해서 훨씬 넓은 범위의 실수를 표현 가능

        * 최대로 표현할 수 있는 값은 약 $1.8 \times 10^{308}$, 이 이상은 inf

        * 최소로 표현할 수 있는 값은 약 $5.0 \times 10^{-324}$, 이 이하는 0

    * C언어의 경우

        * double의 범위가 float보다 넓어 double을 많이 사용

* 컴퓨터는 실수를 근사적으로 표현한다

    * 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장됨

        * 이때  생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

        * 32 bit 실수형 유효자릿수 (10진수) → 약 6자리

        * 64 bit 실수형 유효자릿수 (10진수) → 약 15자리

            ```python
            t = 0.1
            print(f'{t:.2f}')
            ```

    * 근사값으로 저장되는 원리

        * $0.75 = 2^{-1} + 2^{-2} = 0.11_{(2)}$

        * $0.40625 = 2^{-2} + 2^{-3} + 2^{-5} = 0.01101_{(2)}$

    * 소수점을 포함한 2진 실수를 10진수로 변환하는 예시

        * 1001.0011

            | | | |
            | :---: | :---: | :---: |
            | $1 \times 2^{-4}$ | $1 \times 0.0625$ | 0.0625 |
            | $1 \times 2^{-3}$ | $1 \times 0.125$ | 0.125 |
            | $0 \times 2^{-2}$ | $0 \times 0.25$ | 0 |
            | $0 \times 2^{-1}$ | $0 \times 0.5$ | 0 |
            | $1 \times 2^{0}$ | $1 \times 1$ | 1 |
            | $0 \times 2^{1}$ | $0 \times 2$ | 0 |
            | $0 \times 2^{2}$ | $0 \times 4$ | 0 |
            | $1 \times 2^{3}$ | $1 \times 8$ | 8 |

            * 총 합은 9.1875
            