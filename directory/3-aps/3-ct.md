# CT : Computational Thinking

<div style="text-align: right"> 24. 03. 05. ~ </div>

## 0. 서론 - 프로그래밍이 초보자에게 어렵게 느껴지는 두 가지 이유

* 초보자에게 복잡해 보이는 프로그래밍 언어 문법, 복잡한 라이브러리 사용

    * 처음 배울 때는 어렵지만, 훈련을 통해 점차 실력이 늘어감

* *논리 (Hard Logic)*

## 1. 논리와 증명

* Soft Logic

    * 직관은 논리적인 느낌을 주는 것

    * 직관은 나쁜 것이 아님

        * (익숙한 상황에서) 판단이 빠름

        * 정확하지 않음(익숙한 상황에서도 틀릴 수 있음), 강한 착각을 일으킴

    * 일상 생활에서는 Soft Logic이 빠르기 때문에 유용

        * 논리적으로 부정확한 표현을 사용하더라도 어떤 의미인지는 알고 있을 것이라고 생각하고 넘어간다.

* 명제

    * T / F로 판단할 수 있는 문장

    * 전제

        * 배중률 : 무조건 T / F로 판단, 중간이 없는 것
        
        * 모순율 : T / F가 동시에 성립하지 않는 것

    * [참고]

        * 이기다

            * 부정 - 이기지 않다

            * 반대 - 지다

        * 나는 친구를 좋아한다

            * 부정 - 좋아하지 않다

            * 반대 - 싫어한다

* Hard Logic

    * 직관적인 논리로 프로그래밍을 하면, 프로그램이 동작하지 않음

    * 프로그래밍 언어의 표현은 모두 논리학에서 나온 것

    * 사용되는 수많은 알고리즘들을 이해하려면 Hard Logic이 필요함

* 명제 표기

    * $p$ : 한국의 수도는 서울이다.

    * 명제를 부정하면 *참 / 거짓이 반전*된다.

        * ~$p$ : 한국의 수도는 서울이 아니다.

        * $p = T(F)$ 이면 ~$p = F(T)$ 이다.

    * 논리곱 AND (∧)
    
    * 논리합 OR (Inclusive OR, ∨)
    
        * 합격하려면 토플 500점 이상 *혹은* 토익 600점 이상이 필요 : A ∨ B

    * XOR (Exclusive OR)

        * 복권에 당첨되면 자동차 *혹은* 천만원을 줍니다. : A ⊕ B

* 명제의 역, 이, 대우

    * 가정 명제가 거짓이면 전체 명제식은 참이다.

    * 대우 명제가 참이면 기존 명제도 참이다.

    * 주장 : 강아지는($p$) 포유류이다($q$). $p→q$

        * 명제 1(역) : 포유류는($q$) 강아지이다($p$). $q→p$

        * 명제 2(이) : (이 동물이) 강아지가 아니면(~$p$), 포유류가 아니다(~$q$).

        * 명제 3(대우) : (이 동물이) 포유류가 아니면(~$q$), 강아지는 아니다(~$p$).

    * 만약 $p→q$가 거짓이라면,

        * $p$는 반드시 T, $q$는 반드시 F (전체 명제가 F이기 때문에 가정명제는 T)

        * ~$p→q$ : T

        * $p∨q$ : T

        * $q→p$ : T


## 2. 알고리즘 성능 계산법 (시간복잡도 계산)

* 연습 문제 : 다음 재귀식들을 $O()$ notation 수준으로 풀어라. (빅-O 표기법으로 풀어라)

    * $T(n) = T(n - 1) + 1$, $T(0) = 1$

        * $T(n - 1) = T(n - 2) + 1$ → $T(n) = T(n - 2) + 1 + 1 = T(n - 2) + 2$

        * ...

        * $T(n) = T(n - k) + k$

        * n = 0가 되기 위해서는 k = n이 되어야 함

        * $T(n) = T(0) + n$

        * ▶ $O(T(n)) = O(n)$

    * $T(n) = T(n - 1) + n$, $T(0) = 1$

        * $T(n - 1) = T(n - 2) + (n - 1)$ → $T(n) = T(n - 2) + (n + (n - 1))$

        * $T(n - 2) = T(n - 3) + (n - 2)$ → $T(n) = T(n - 3) + (n + (n - 1) + (n - 2))$

        * ...

        * $T(n) = T(n - k) + (n + (n - 1) + (n - 2) + ... + (n - (k - 1)))$

        * $T(n) = T(0) + (n + (n - 1) + (n - 2) + ... + 1) = 1 + n(n + 1) / 2$

        * ▶ $O(T(n)) = O(n^2)$

    * $T(n) = T(n - 1) + log n$, $T(0) = 1$

        * $T(n - 1) = T(n - 2) + log(n - 1)$ → $T(n) = T(n - 2) + log n(n - 1) <= T(n - 2) + nlogn$

        * ...

        * $T(n) <= T(n - k) + nlogn$

        * $T(n) = T(0) + (log n + log(n - 1) + ... + log(1)) <= 1 + nlogn$

        * ▶ $O(T(n)) = O(nlogn)$

    * $T(n) = T(n / 2) + 1$, $T(1) = 1$

        * $T(n / 2) = T(n / 2^2) + 1$ → $T(n) = T(n / 2^2) + 2$

        * $T(n / 2^2) = T(n / 2^3) + 1$ → $T(n) = T(n / 2^3) + 3$

        * ...

        * $T(n) = T(n / 2^k) + k$

        * $n = 2^k → k = log_2 n$ 대입하면

        * $T(n) = T(1) + log_2 n = log_2 n + 1$

        * ▶ $O(T(n)) = O(log n)$




<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$']]},
    messageStyle: "none",
    "HTML-CSS": { availableFonts: "TeX", preferredFont: "TeX" },
  });
</script>

